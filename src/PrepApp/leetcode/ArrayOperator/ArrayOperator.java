package PrepApp.leetcode.ArrayOperator;

import DSA.ListNode;

import java.util.Arrays;
import java.util.List;

public class ArrayOperator {
    public boolean uniqueOccurrences(int[] arr) {
        return false;
    }

    public List<List<String>> groupAnagrams(String[] strs) {
        return Arrays.asList(Arrays.asList(new String[]{}));
    }

    public List<Integer> largestDivisibleSubset(int[] nums) {
        return Arrays.asList(0,0,0);
    }

    public int[] rearrangeArray(int[] nums) {
        return new int[]{};
    }

    public long largestPerimeter(int[] nums) {
        return 0;
    }

    public int findLeastNumOfUniqueInts(int[] arr, int k) {
        return 0;
    }

    public int furthestBuilding(int[] heights, int bricks, int ladders) {
        return 0;
    }

    public int mostBooked(int n, int[][] meetings) {
        return 0;
    }

    public int maxSumAfterPartitioning(int[] arr, int k) {
        return 0;
    }

    public int missingNumber(int[] nums) {
        return 0;
    }

    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        return 0.0;
    }

    public int[] sortedSquares(int[] nums) {
        return new int[]{};
    }

    public ListNode removeNthFromEnd(ListNode head, int n) {
        return null;
    }

    public int bagOfTokensScore(int[] tokens, int power) {
        return -1;
    }

    public int maxFrequencyElements(int[] nums) {
        return 0;
    }

    public int[] productExceptSelf(int[] nums) {
        return new int[]{};
    }

    public boolean hasCycle(ListNode head) {
        return false;
    }
}
